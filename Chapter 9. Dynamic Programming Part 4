1049. Last Stone weight2
最后一块石头的重量

题目是挺有意思的，但是不知道跟背包问题有什么关系

本题就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小
物品的重量和价值相等，都是stone[i]

五部曲：
1. 确定dp数组及其下标的含义： dpj：最多可以背的重量为dpj
2. 递推公式： dp[j] = max(dp[j], dp[j - stone[i]] + stone[i)
3. 初始化：背包的最大容量是多少呢？是石头总重量的一半
    所有的都可以初始化为0
4. 遍历顺序：物品for在外层，背包for在内层，背包倒叙

如何转化为01背包问题，是我需要体会的点

494 Terget sum 目标和

确实这道题一看，跟背包问题没啥关系。

分析一下这个题是怎么变成背包问题的

首先，数组中肯定有一部分前面是正号，那么这些元素的集合称为left
然后有一部分前面是负号，这些元素的集合称为right
那么，有 left + right = sum 
left - right = target
所以 left - (sum - left) = target
left = (sum + target) / 2

所以问题就变成了如何在集合nums中找出left出来

问题就变成了，用nums装满容量为left的背包，有多少种方法

这个背包问题也不一样了，之前是问能装多少，现在是问有多少种装法

五部曲：

1. 确定dp数组和含义：二维数组，dp[i][j] 使用下标为[0,i]的nums[i]能够凑满j这么大容量的背包，有dp[i][j]种方法

2. 递推公式
dp[i][j] = dp[i-1][j] + dp[i-1][j - nums[i]]
这个的思路也是，到第i层了，就是要考虑i个物品了，那么有i两种思路，一种是不放第i个物品，装满j的方法就是dp[i-1][j]
然后就是，如果放第i个物品，那么剩余空间是j - nums[i]，剩下可以放的物品编号是i - 1

所以可以得到上面的公式

3. 初始化：先确定递推方向，是从上和左上推过来的，因此要初始化第一行，第一列
装满背包0的方法是1，就是不装东西（第一列）
第一行，只放物品0，把容量为j的背包填满，那么就只能是dp[0][nums[0]] = 1 ，其他均为0 。

这里有个例外，就是物品的数值是0
比如说前两个都是0，那么装满背包0的方法有几种？按照组合数量求，有2^t种方法（遍历的时候，出现了一个新的0，才统计入一个0）

程序里面有个小细节，i-1其实是当前元素编号

474. Ones and zeroes 0 和1

五部曲：

这道题很有难度的，因为他的背包容量是有两个维度的，m和n

然后需要想明白dp的含义是什么，dp的含义是个数，所以递推公式最后是+1

初始值和边界值的处理

这道题建议看视频来处理

