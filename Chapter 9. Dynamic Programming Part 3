01 背包问题理论基础
暴力解法：每个物品都有取或者不取两种状态，去罗列

注意一点：01背包里面的物品只有一个

这里需要注意的是，dp数组的定义
可以定义i是物品，j是背包容量
dp[i][j]表示从下标为0到i的物品里面任取，放进容量为j的背包，价值总和最大是多少

递归公式：可以抽象为两个过程
1. 不放物品i：背包容量为j，里面不放物品i的最大价值就是dp[i-1][j]
2. 放物品i：背包空出物品i的容量之后，背包的剩余容量为j - weight[i]，然后检查这个容量下，i-1物品可以放下多少价值，再加上物品i的价值

数组初始化：背包容量为0，那么价值肯定为0（初始化第一列）
存放编号为0的物品，各个容量的背包所能存放的最大价值，因此就是j>weight[0]的时候，dp为0.大于等于的时候，就是物品0的价值

这里面讲到了遍历顺序，先遍历物品和先遍历背包是一样的， 结论是这样的，但是我没太理解内核，就先跳过了

滚动数组（力扣仍然没有原题，理解一下就行了）
背包问题的状态是可以压缩的，如果把i-1层的数据直接拷贝到i层，那么就可以只用一个一维数组了

那么这时候可以直接用滚动数组，前提是上一层的数据可以直接拷贝到下一层来

dp[j]是什么意思？背包重量为j时的最大价值
一维的递推公式可以更加简单地写为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

滚动数组的初始化：可以全部初始化为0（价值都为正的时候） 自己推导一下，很容易想明白

遍历顺序：
这里面很关键的一点就是，对于物品也是要遍历的，即使这是个一维数组，仅仅遍历背包容量没法做题

还有就是遍历的顺序；背包大小从大到小遍历

要先遍历物品，再遍历背包，背包大小从大到小遍历，顺序不能有任何错误
（自己需要理解一下为什么这么做）

力扣题目：
416 Partition equal subset sum 分割等和子集
将集合分割成两个部分，每个部分的元素和是相等的，可以的话返回true，不能的话返回false

问题嵌套：
背包的体积为sum/2
背包要放入的商品（集合里面的元素）重量为元素的数值，价值也为元素的数值
背包如果正好装满，说明找到了总和为sum/2的子集
背包中每个元素不可重复

怎么算是背包装满了？ dp[target] = target

这是一个比较tricky的点，背包正好装满，前提是重量，价值都是元素的值

初始化的问题：dp[0]一定是0，然后要是都是正整数，那么其他的值可以初始化为0，要是有负数，那么就初始化为负无穷

代码实现还是有很多细节的，二刷的时候可以多多关注一下
