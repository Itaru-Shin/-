
669. Trim a binary search tree 修剪二叉搜索树
第一时间可以想到思路，就是子树的移动，剩下的就是如何确定自己的递归逻辑了

参数：root，low，high
返回值：root
终止条件：root为空返回（trim的操作不是在终止条件上进行的，因此可以直接返回空）
单层逻辑（最难的部分）：如果当前节点的元素小于low的值，则返回右子树。如果大于，则返回左子树
最后要返回root节点

ps：这里的返回，更像是覆盖的过程，或者说是重新build树的过程。由于在递归过程中会使用left和right来记录树的生长过程。这其实就是长树

ps:递归中的return是找树的过程，left，right的覆盖是种树的过程

108. Convert sorted array to binary search tree
第一想法就是中序遍历
题目中要求的是height-balanced的bst，高度平衡的意思是左右两个子树的高度差绝对值不超过1
递归的从中间节点分开，然后左右地去找，去构建树

用下标来操作原数组，所以是左闭右闭的区间。
传入的参数：数组，左索引，右索引
返回值：treenode
终止条件：
单层逻辑：取中间的元素。（这里面提到很关键的一点，就是数据越界，直接写(left+right)/2可能会直接溢出，因此写成left+（right-left)/2
中间元素构造节点：root = new (nums[mid)

注意一下边界的处理，在这里面是left>right的时候达到边界了
为什么会如此呢？这是因为在递归的时候，有个right给的是mid - 1,left给的是mid + 1，当只有一个元素的时候，会超出索引

538. Convert BsT to Greater Tree 把二叉搜索树转化为累加树
确实，问题就在于如何完成累加这个操作呢。
对于一个数组，我们是很容易知道要怎么做，就是从后向前累加，就能完成题目的要求
但是如果是个二叉搜索树呢。其实可以用反中序遍历，就可以了（这一点很关键）

递归的思路：
参数：curnode，同时需要定义一个pre，来指向前一个节点的数值

终止条件：遇空返回

单层逻辑（最难的地方）：
采用右中左的顺序来遍历二叉树，中间节点的处理就是让cur的数值加上前一个节点的数值，同时覆盖掉现有的cur的数值
遍历的次序真的是很有趣的一点啊
