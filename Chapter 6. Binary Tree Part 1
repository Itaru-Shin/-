今儿主要学习二叉树，感觉是很大的一个章节，需要对应的篇幅是很多的

二叉树题目的分类：
  二叉树的遍历方式
  二叉树的属性
  二叉树的修改与构造
  求二叉搜索树的属性
  二叉树公共祖先问题
  二叉搜索树的修改与构造

二叉树的种类：
满二叉树（full binary tree)：所有的非叶子结点都有两个子节点，并且所有的叶子结点都位于同一个层级上。
也就是说，满二叉树的话，根据层数，是能够精确地求出节点的数量的。

完全二叉树（complete binary tree）：除了最后一层以外，所有的层都被填满，且最后一层的节点尽可能靠左。

满二叉树也是一种完全二叉树

堆就是个完全二叉树，优先级队列就是个堆

二叉搜索树：左子树的所有节点的值小于根节点的值。右子树所有节点的值大于根节点的值。（左边小，右边大）

平衡二叉搜索树：（AVL树）它是一棵空树或它的左右两个子树的高度差的绝对值不能超过1，左右子树都是平衡二叉搜索树

C++中的map，set，multimap，multiset的底层实现都是平衡二叉搜索树：
  set是存储单一类型的元素，且元素中不能有重复的元素
  multiset相比于set，则是可以存储重复的元素
  map相比于set，则是可以将存储的元素升级为键值对，但是不能有重复的键
  multimap可以有重复的键，然后可以让同一个键对应多个值

所有的undorded的话，底层数据类型就是哈希表了

二叉树可以链式存储，也可以顺序存储。链式存储方式就用指针，顺序存储方式就用数组

二叉树的遍历方式：
深度优先：前序遍历，中序遍历，后序遍历
广度优先：层次遍历
这几个遍历的方式的顺序自己应该多看看，有一些区别，但是不知道为什么要有这些区别：
  前序遍历常用于复制树结构，中序遍历用于生成有序输出，后序遍历用于删除或释放树节点。（需要深入体会）

深度优先用栈来实现，广度优先用队列来实现

*二叉树的递归遍历
