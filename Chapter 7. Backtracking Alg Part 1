回溯算法，也是一个比较多的知识点
理论基础：
回溯法也叫做回溯搜索法，是一种搜索法。
回溯是递归的副产品，只有有递归就会有回溯。回溯函数也就是递归函数，指的都是一个函数

回溯法的效率：很难，也不好理解，但是并不是高效的算法。因为回溯的本质是穷举，穷举所有的可能，穷举所有的可能，然后选出想要的答案
想要回溯法高效一些，可以加一些剪枝的操作，但是改变不了回溯法是穷举的本质

为什么还要选这个算法呢？因为有一些问题只能用暴力解法，加一些剪枝就不错了

回溯法解决的问题：
组合问题：N个数里面按一定的规则找出k个数的集合
切割问题：一个字符串按照一定规则有几种分割方式
子集问题：一个N个数的集合里面有多少符合条件的子集
排列问题：N个数按一定规则全排列，有几种排列方式
棋盘问题：N皇后，解数独等等（？这是什么呢）

组合是不强调顺序的，但是排列是强调顺序的

回溯法解决的问题都可以抽象为树形结构。集合的大小构成了树的宽度，递归的深度构成了树的深度

横向遍历+纵向递归

回溯的模板：
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

77. Combinations 组合
这道题的直接解法其实看上去很容易，就是不停地嵌套for循环就好了
但是如果是大几十上百层的for循环，是很难写的。这时候就要用到回溯，虽然也是暴力，但是至少能写出来

递归的作用是什么？递归的作用就是开k层for循环（就是需要目标子集的元素数量）

回溯问题可以抽象为N叉树

看了视频之后，确实更加深刻的理解了，什么叫做横向的for，纵向的递归。startindex是如何在整个过程中如何更新的

216. Conbination Sum 3
本质还是在一个固定的集合中找到和为n的k个数的组合

三部曲：
result和path用来存储结果
参数：n，k，startindex（组合问题中的标志性参数，用来防止重复）
返回值一般都是没有的
终止条件：当path的size和k相等了，就终止了。然后此时的和为目标值的时候，就可以记录进result了

单层逻辑：i的上限可以确定了。然后就是回溯的处理过程，加了值就要减回来

整体的思路有了概念了，感觉还行

17. letter combinations of a phone number 电话号码的字母组合
这道题相比于之前，多了一道映射的过程。
每个数字都有了三个字母进行映射

递归的深度：输入的数字的个数

定义一个字符串s来收集路径，result用来保存结果，都定义为全局
定义一个index，记录的是树的深度，也就是递归到第几个数字了

终止条件：如果index等于输入的数字的长度，就认为到达终止条件了

单层逻辑：这里面需要注意的一点，单层里面的循环，是遍历每一个数字代表的字母

就是相对麻烦了一些，不过还是比较简单的
