今儿的任务就是刷三道题：

530. Minimum Absolute Difference in BST二叉搜索树的最小绝对差
看标题不知道是啥意思
是要返回树中的最小的差值。首先自己分析一波，根据BST的性质，BST是有序的
最直观的想法就是把BST转化为有序数组，然后遍历一遍数组

题解中说，在BST的中序遍历过层中，就可以直接计算结果了，中序是左中右。
这里面需要掌握的技巧，就是在递归遍历的过程中如何记录前后两个指针

如果是递归的话，尝试写三要素：
参数：需要传入指针是肯定的了，因为维护了一个全局的result，所以不用传入result了，问题就是传入的是什么指针。由于一开始给的就是一个root，那么传入的肯定就是root指针了
返回值：由于维护了全局的result，所以不用返回值了

终止条件：当前指针为空的话，就可以直接返回了

单层逻辑：肯定是中序，就是如何进行结果处理，以及pre指针如何更新的

发现我自己对于递归的理解还是不够深入，在这里需要注意的一点是，python的函数有个默认的return，就是在函数运行完毕之后，会默认return None，前提是没有别的显式的return了

501. Find Mode in Binary Search Tree二叉搜索树中的众树
依旧是个看标题不知道啥意思
众树：出现频率最高的元素

依旧是那个性质：对于BST而言，中序遍历就是有顺序的

这道题还算是思路比较直接，有了前面的题的铺垫，会简单一些

236. Lowest Common Ancestor of a binary tree二叉树的最近公共祖先
看标题仍然不知道是啥，然后为什么用的是lowest这个单词

descendant是后代的意思
英文的审题对我而言也是考验呀

这道题应该从低到高来进行遍历，需要用到回溯，后序遍历就是一种回溯

需要判断情况，如果遇到q就返回q，遇到p就返回p。需要注意的是，p和q本身也是自己的祖先

递归法：
参数：root肯定是需要的。然后是节点p和节点q（需要注意的是，这里的p和q是节点，而不是数值）。返回值呢是p或者q，也就是节点
终止条件：遇到空的话，就返回空
还有就是root是q或者p，也要返回root

单层逻辑：这里面是需要判断遍历整棵树，还是遍历一条边

整体的逻辑仔细想一想就没啥别的问题了，细节比较多
