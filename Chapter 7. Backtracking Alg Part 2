39. Combination Sum

这道题跟之前的差距在于，数组中的元素是可以被无限选取的，这是跟之前的题的区别

回溯三部曲
依旧定义两个全局变量，result结果集，path存放结果
参数：需要用到startindex来控制for循环的起始位置（什么时候用startindex呢，如果是一个集合求组合的话，就会用得到，如果多个集合取组合，各个集合之间互不影响，就用不到，电话号码的那道题）

终止条件：这个题由于是无限取的，所以树的理论深度是可以很深的，终止条件就是sum大于等于target

单层逻辑：还是从startindex开始，搜索candidate集合，这里由于是可以取重复元素，所以一些细节发生了改变

40 Combination Sum 2
跟之前的题相比，就是不允许元素重复了，感觉稍微改动一下程序就行了呀
还有一个区别：元素是有重复的
有重复的元素，但是不能有重复的组合

去重操作： 如果把所有的组合求出来，然后再用set或者map去重，很容易超时，所以要在搜索的过程中去掉重复元素
去重的元素在哪儿？在同一个树层上

树层去重的话，需要对数组进行排序！
剩下的思路算是比较清晰了

这里面的去重确实是一个很好的思路，之后二刷的话需要重点考虑

131 Palindrome partitioning
这两个英文单词需要学习一下
Palindrome 回文，正着反着都一样，发音自己谷歌
partitioning 分区
意思是回文序列的分区，分割

切割其实类似于组合问题

切割线的定义：通过startIndex来进行追踪，要是index到了字符串的末尾了，那么说明结束了

切割的片段是如何确定的呢？就是[startIndex, i] （这个确实很巧妙）

所以说，一共就是切两刀，一刀是startIndex，一刀是i，startIndex是横向遍历，i是纵向遍历

如何判断回文序列：双指针，一个从前向后，一个从后向前

整体的思路比较统一了。
