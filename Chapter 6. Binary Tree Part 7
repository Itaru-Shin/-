235. Lowest common ancestor of a binary search tree
二叉搜索树是有序的，可以利用这个特点，中间节点一定是在[p,q]之间的
那么如何判断是不是最近公共祖先？

这里面也有一个很有趣的性质哈，那就是从上到下的去递归遍历，第一次遇到的cur节点是pq之间的，那么他一定是最近公共祖先（这一点很关键呀）

由于题目中并不涉及中间节点的处理，所以就无所谓遍历顺序的了

递归法三部曲：
参数：当前节点，p q
终止条件：遇到空就返回
单层逻辑：这时候就需要分清楚是找左树，还是找右树了。
细节就是，需要区分好是遍历一条边，还是遍历整棵树，写法是不一样的，应该在二刷的时候深入体验一下

701 Insert into a binary search tree 二叉搜索树中的插入操作
这道题最初的思路是想着根据二叉树的规则去遍历，然后将数值插入进去
但是题解的思路好像说的很简单，没get到点
ok看视频之后懂了，原来所有要插入的节点，都可以在叶子结点中找到他的位置（又是一个神奇的特性）。只要不要求树的平衡，那么这道题其实挺简单的

450 Delete Node in a BST
删除节点就不像之前的增加节点那么简单了
递归法要素：
参数：根节点，key
返回值：返回根节点
终止条件：遇到空返回
单层逻辑（比较复杂的部分）：
1. 没有找到删除的节点，直接返回了
找到删除的节点的话：
2. 左右都为空，直接删除节点，返回null
3. 删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
4. 右孩子为空，则左孩子补位
5. 左右都不空，则将左孩子放到右子树的最左边节点的左孩子上（放到右子树的左下角去）

递归还是得多练
