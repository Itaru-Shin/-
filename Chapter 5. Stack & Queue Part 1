栈与队列的理论基础
队列：先进先出
栈：先进后出
1. stack 是容器吗？
stack 在 C++ 中并不是一种独立的容器，而是一个容器适配器（container adapter）。容器适配器是在其他底层容器的基础上构建的，它提供了一组专门的接口来满足某种特定的数据结构或算法需求。stack 的底层容器可以是 deque（默认）、vector 或 list。
4. stack 提供迭代器来遍历 stack 空间吗？
不提供。由于 stack 是一种后进先出（LIFO, Last In First Out）的数据结构，它仅允许访问栈顶元素并进行压栈和弹栈操作，因此 stack 不支持迭代器来遍历其元素。stack 设计的初衷是为了限制访问，仅能通过 top 访问栈顶元素，而不允许遍历内部数据。
如果你需要遍历 stack 中的元素，可以考虑在使用 stack 之前将其底层容器（如 deque 或 vector）直接暴露出来，然后在该容器上使用迭代器进行遍历。

栈是以底层容器完成所有工作的，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）

deque（双端队列，double-ended queue）是一种在 C++ 标准模板库（STL）中提供的序列容器，它允许在序列的两端（前端和后端）进行高效的插入和删除操作。

deque 的特点
双端操作：与 vector 不同，deque 支持在序列的两端进行插入和删除操作。这意味着你可以在 deque 的前端使用 push_front 和 pop_front，在后端使用 push_back 和 pop_back，而这些操作的时间复杂度都是 O(1)。

随机访问：deque 允许随机访问元素，类似于数组或 vector，你可以通过下标访问 deque 中的元素，时间复杂度为 O(1)。

动态大小：与 vector 类似，deque 的大小是动态调整的，当需要增加或减少容量时，deque 会自动调整其大小以适应新元素的插入或删除。

不连续存储：与 vector 不同，deque 的内部实现并不是将所有元素存储在一个连续的内存块中，而是使用一组连续的小块内存来存储元素。这种实现方式使得 deque 能够高效地进行前端的插入和删除操作，同时也能高效地进行随机访问。

Leetcode题目：
232. Implement Queue using Stacks，用栈来实现队列
这是一道模拟题
用两个栈来实现队列的模拟过程真的很有意思，这里面需要一个栈叫做stack in，一个栈叫做stack out。
如果队列要push的话，直接就往stack in里面push就行了。
但是如果要pop的话，就要先从入栈pop出来，push到出栈中，然后再从出栈中pop（相当于负负得正了）
两个栈实现一个队列=负负得正，这可真是个有趣的想法

工业级别代码的注意：一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出现问题

这道题里面，python的代码是利用list来模拟一个stack，然后使用append来模拟在末端的加入和弹出操作。

Tips：deque的发音为deck

255. Implement Stack using Queues 使用队列来模拟栈
这道题的难点也是在于，你只能使用先进先出的规则，来实现先进后出的效果
因为队列是先进先出的，为了让最后一个进来的先出去，那么就需要前面的元素进行让路，让他们先出去到另一个队列中备份，然后让最后一个元素出去，再把之前在前面的元素填回来
list既可以用来实现栈，又可以用来实现队列
append() + pop() = stack
append() + pop(0) = queue
优化：只需要将挡在前面的元素，弹出的时候直接加在队列的末尾就可以了，不需要一个新的队列
这道题跟之前那道题可以说是大同小异

20. Valid Parentheses 有效括号
栈是非常适合做匹配类型的题目的
这里面有个重要的做法：动手之前分析好题目
整体而言还是个比较简单的题目

1047: Remove All Adjacent Duplicates in String
我的第一思路是还需要加个循环来判断判断，因为题目中提到了直至无法再发现新的重复字符。但是好像并没有这个必要
这道题整体还是很简单的，就是判断当前的元素，是不是和栈顶的元素相等。如果相等的话，就要pop。
这里面有个细节要考虑，就是因为要返回res[-1],需要判断res是不是空的，不然会出现索引错误。
