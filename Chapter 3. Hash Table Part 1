今天开始学习哈希表
哈希表的定义：Hash table
哈希表是根据关键码的值而直接进行访问的数据结构（官方解释）
数组就是一张哈希表，关键码就是数组的下标，然后通过下标直接访问数组中的元素

哈希表解决的问题：快速判断一个元素是否出现在集合里

哈希函数：如何将一段特定的字符或者其他的东西（例如人名等），转化为哈希表中的索引数字，这个过程就是哈希函数。
文中提到的一个： hashFunction=hashCode(name) % tablesize， 这就可以将其他的东西转化为索引了（映射）

如果数量大于哈希表的大小，避免不了会被同时映射到同一个索引下，那么就需要引出 哈希碰撞

哈希碰撞：
小王小李都被映射到了索引下标为1的位置
解决办法：拉链法，线性探测法

拉链法：将小王和小李都存在索引1中，索引1对应的位置成了一个链表
选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间

线性探测法：
要保证哈希表的大小大于数据大小，依靠哈希表中的空位来解决碰撞问题
如果放了小李，那么就向下找一个空位放小王的信息

常见的三种哈希结构：
数组，集合set，映射map

C++下面的三种set：
set：红黑树，有序，不可重复，不可更改
multiset：红黑树，有序，可以重复，不可更改
unordered_set：哈希表，无序，不可重复，不可更改

三种map：
map：红黑树，有序，不可重复，不可更改
multimap：红黑树，有序，可以重复，不可更改
unordered_map：哈希表，无序，不可重复，不可更改

使用情景：当要使用集合解决哈希问题的时候，优先使用unordered_set，因为查询和增删效率是最优的。如果需要集合是有序的，就用set；如果不仅有序还要有重复数据，就用multiset

注意的一点：判断一个元素是否存在过，用哈希法

Leetcode：
242 Valid Anagram
  Anagram指的是回文重组词，比如listen和slient，数量和字母是一样的
  数组就是简单的哈希表

  解题的关键在于，如何确定关键值，然后如何完成映射。这道题的关键值就是英文字母，然后声明一个大小为26的数组，就可以和字母一一对应。值就是字母出现的顺序。
  关键的一点在于，不需要在意顺序！

  题解中有ord()这个函数，是ordinal的缩写，表示次序，可以理解为返回一个字符在unicode中的次序。
  与之相对应的函数为chr（）
