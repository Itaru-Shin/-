Part2的话一般就是一些leetcode题目了

150. Evaluate Reverse Polish Notation
逆波兰表达式，确实是第一次听到这个说法，感觉很有趣。
查看chatGpt后得知，这种表示方法非常适合堆栈计算，用来作为一些计算器的设计（以前的一些非科学计算的计算器可能就是这种算法）
而且这种表达方式是不用care运算优先度的。
看到题目的第一想法是受阻的，学习一下题解的思路。
看懂了逆波兰表达式的算法后也是比较简单的：
  碰到数字，就压入栈
  碰到运算符，就用栈顶的前两个数字进行运算，把结果压入栈顶

from operator import add, sub, mul

def div(x, y):
    return int(x/y) if x*y>0 else -(abs(x) // abs(y))

class Solution:
    op_map = {'+': add, '-': sub, '*': mul, '/': div}

    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token not in {'+', '-', '*', '/'}:
                stack.append(int(token))
            else:
                op2 = stack.pop()
                op1 = stack.pop()
                stack.append(self.op_map[token](op1, op2))
        return stack.pop()

这个代码有一些细节是值得分析一波的：
from operator import add, sub, mul
python是有现成的运算符的，为什么还要import这些运算符呢？这是因为要把这些基础运算改为函数的形式，这样的话更加容易地调用，就跟函数一样

然后是专门定义的div：因为python中的//默认是向负无穷大取整，对于结果是正数的话还好说，但是如果结果为负数的话，就不对了，因此需要专门定义一个div出来

然后是这个op_map字典的定义：将数学符号和函数名对应起来，这样在检测到数学符号的时候，可以用函数符号的形式进行函数调用，这一步真的很妙，函数调用的思想值得学习

239: Slinding Window Maximum
竟然是一道困难的题目诶，也是在这个训练营第一次刷困难的题目，看看思路先

这个题的算法挺牛的我只想说。最直接的思路就是，我存储了窗口内的所有的元素，然后计算得到其中的最大值，然后返回最大值。
窗口移动的时候，就重新载入一遍新的元素。
这样的问题是时间复杂性太大了，每次都要载入元素不说，还得排序找到最大值，想想就十分麻烦
那么现在的思路就是：我能不能不用每次都载入新的元素？我只要pop掉一个元素，然后push一个新的元素就好了
然后在通过一个新的List进行排序，返回最大值？确实会少了一些复杂性，但是还是有提升的空间，那就是，引入了新的空间，并且还是对窗口内的元素进行排序。
现在想想，移动窗口的时候，会发生什么情况呢？对于被删除掉的元素，有可能删除掉最大元素，有可能删除不掉。那么如果删除掉了最大元素，就把最大元素pop掉，但是要保证次大元素是在里面的。
如果没删除掉最大元素，就不用管。
对于新加的元素，通过维护一个单调队列进行记录。

这个单调队列很牛逼，可以维护住从大到小的几个主要的元素。
这个题的思路好强大，可以多刷几次熟悉熟悉

347. Top K Frequent Elements
题目是很容易看懂的，但是一开始不知道跟栈有什么关系
原来是跟队列有关系
然后这道题需要具体的分析：要统计频率，如何统计呢？那就必然要用map了
统计完之后，直观的思路就是针对map中的频率进行排序，然后输出前k个就好了
题解中用到的是优先队列：
  优先队列提供的api就是在顶部pop，在底部push，看上去就是个queue，其实是个堆，因为他在内部会根据元素的权重进行排序

大顶堆还是小顶堆的问题：
  一开始的直观思路确实是用大顶堆，然后pop出来顶部元素应该就行了。map中有多少个不同的key，就维护一个多大的堆。然后pop k次，我感觉应该是没啥问题的
  然后小顶堆，直接维护一个k大小的堆，每次加一个元素进去，pop一个最小的值出来，留下来的就是前K大的了，很棒的算法。

在代码实现的过程中，发现了一些有趣的点：
1. heapq堆队列算法， 也被称为优先队列算法，只有小顶堆的实现方式
2. heapq中可以push的元素，可以是个元组（frequency，value），他会按照元组的第一个元素进行排序
3. Python中没有现成的大顶堆的数据结构，可以将frequency改成负数，然后按照小顶堆进行排序就行了。

总结篇：
可以出一道面试题：栈里面的元素在内存中是连续分布的么？

这个问题有两个陷阱：

陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。
陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。

越是高级的语言，越是容易忽略底层的具体实现，看来c++还是挺有必要的呀
